ObjectMapper mapper = new ObjectMapper();
User mockUser = mapper.readValue(
    new ClassPathResource("data/user.json").getFile(),
    User.class
);

when(mongoTemplate.findById("1", User.class)).thenReturn(mockUser);
#-------------------

  @TestConfiguration
public class MockMongoConfig {

    @Bean
    @Primary
    public MongoTemplate mongoTemplate() {
        return Mockito.mock(MongoTemplate.class);
    }
}
//----------------------
  @SpringBootTest
@Import(MockMongoConfig.class)
class MyServiceTest {
    @Autowired
    MongoTemplate mongoTemplate;  // this is the mocked one

    // same as before
}
//---------------------
  
@TestConfiguration
public class MockMongoTemplateConfig {

    @Bean
    @Primary
    public MongoTemplate mongoTemplate() throws IOException {
        MongoTemplate mongoTemplate = Mockito.mock(MongoTemplate.class);

        // Load JSON data into list
        ObjectMapper mapper = new ObjectMapper();
        List<User> mockUsers = Arrays.asList(
            mapper.readValue(
                new ClassPathResource("data/users.json").getFile(),
                User[].class
            )
        );

        // Stub find()
        Mockito.when(mongoTemplate.find(Mockito.any(Query.class), Mockito.eq(User.class)))
               .thenReturn(mockUsers);

        // Stub findOne()
        Mockito.when(mongoTemplate.findOne(Mockito.any(Query.class), Mockito.eq(User.class)))
               .thenAnswer(invocation -> 
                   mockUsers.stream().findFirst().orElse(null)
               );

        // Stub findById()
        Mockito.when(mongoTemplate.findById(Mockito.anyString(), Mockito.eq(User.class)))
               .thenAnswer(invocation -> {
                   String id = invocation.getArgument(0, String.class);
                   return mockUsers.stream()
                                   .filter(u -> u.getId().equals(id))
                                   .findFirst()
                                   .orElse(null);
               });

        return mongoTemplate;
    }
}


  
----------------------------------------------------------------------------

@TestConfiguration
public class MockMongoTemplateConfig {

    @Bean
    @Primary
    public MongoTemplate mongoTemplate() throws IOException {
        MongoTemplate mongoTemplate = Mockito.mock(MongoTemplate.class);

        // Load all test documents into memory
        ObjectMapper mapper = new ObjectMapper();
        List<Document> transactions = Arrays.asList(
            mapper.readValue(
                new ClassPathResource("data/transactions.json").getFile(),
                Document[].class
            )
        );

        // find(Query, Document.class)
        Mockito.when(mongoTemplate.find(Mockito.any(Query.class), Mockito.eq(Document.class)))
               .thenAnswer(invocation -> {
                   Query query = invocation.getArgument(0, Query.class);
                   return transactions.stream()
                           .filter(doc -> matchesQuery(doc, query))
                           .collect(Collectors.toList());
               });

        // findOne(Query, Document.class)
        Mockito.when(mongoTemplate.findOne(Mockito.any(Query.class), Mockito.eq(Document.class)))
               .thenAnswer(invocation -> {
                   Query query = invocation.getArgument(0, Query.class);
                   return transactions.stream()
                           .filter(doc -> matchesQuery(doc, query))
                           .findFirst()
                           .orElse(null);
               });

        return mongoTemplate;
    }

    /** Enhanced query matcher */
    private boolean matchesQuery(Document doc, Query query) {
        Document q = query.getQueryObject();

        for (Map.Entry<String, Object> entry : q.entrySet()) {
            String field = entry.getKey();
            Object condition = entry.getValue();
            Object actual = doc.get(field);

            if (condition instanceof Document) {
                // Operator-based condition
                Document condDoc = (Document) condition;
                for (Map.Entry<String, Object> cond : condDoc.entrySet()) {
                    String op = cond.getKey();
                    Object expected = cond.getValue();

                    switch (op) {
                        case "$gt":
                            if (!(compare(actual, expected) > 0)) return false;
                            break;
                        case "$lt":
                            if (!(compare(actual, expected) < 0)) return false;
                            break;
                        case "$gte":
                            if (!(compare(actual, expected) >= 0)) return false;
                            break;
                        case "$lte":
                            if (!(compare(actual, expected) <= 0)) return false;
                            break;
                        case "$in":
                            if (!(expected instanceof Collection) ||
                                !((Collection<?>) expected).contains(actual)) {
                                return false;
                            }
                            break;
                        case "$regex":
                            if (!(expected instanceof String)) return false;
                            String pattern = (String) expected;
                            if (actual == null || !actual.toString().matches(pattern)) {
                                return false;
                            }
                            break;
                        default:
                            throw new UnsupportedOperationException("Operator not supported: " + op);
                    }
                }
            } else {
                // Simple equality
                if (!Objects.equals(condition, actual)) {
                    return false;
                }
            }
        }
        return true;
    }

    /** Helper for number/string comparison */
    @SuppressWarnings({ "rawtypes", "unchecked" })
    private int compare(Object a, Object b) {
        if (a == null || b == null) return -1;
        if (a instanceof Number && b instanceof Number) {
            return Double.compare(((Number) a).doubleValue(), ((Number) b).doubleValue());
        }
        if (a instanceof Comparable && b instanceof Comparable) {
            return ((Comparable) a).compareTo(b);
        }
        return a.toString().compareTo(b.toString());
    }
}


-------------------------------------------------------


  MongoMappingContext context = new MongoMappingContext();
        MappingMongoConverter converter = new MappingMongoConverter(NoOpDbRefResolver.INSTANCE, context);
        converter.afterPropertiesSet();

        // Create a spy so you can override methods
        MongoTemplate realTemplate = new MongoTemplate(Mockito.mock(MongoDatabaseFactory.class), converter);
        MongoTemplate spyTemplate = Mockito.spy(realTemplate);
